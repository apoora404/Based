# based_trade.py — Based 지정가 자동 매매 (미체결 전부 취소 / 최소 보유 / 포지션 탭 청산 / 무콘솔 팝업 대기 / 파일 로깅)
# - 창 크기 1440x1080
# - 진입: 오더북 가격 클릭 → 75% → 주문하기(지정가). 체결 지연 시 미체결 전부 취소 후 재주문
# - 보유: 최소 160~200초(약 5~6분)
# - 청산: 포지션 탭에서 청산 버튼 클릭(시장가 닫기/지정가 종료 시도). 미체결 취소는 하지 않으며, 실패 시 새로고침 후 재시도
# - 잔액 종료: 포지션 0개일 때만, 잔액이 임계값 이하가 연속 N회 감지되면 종료
# - 콘솔 숨김 빌드용: input() 사용 안 함. Tk 팝업으로 로그인/지갑 연결 대기
#
# 빌드 예시(콘솔 숨김):
#   pyinstaller --onefile --noconsole based_trade.py
#
# 실행 로그 기준 파일: based_trade.log

import os, time, random, re, sys, json
import tkinter as tk
from tkinter import messagebox
import logging

from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import (
    WebDriverException, TimeoutException, NoSuchElementException, ElementClickInterceptedException
)
from selenium.webdriver.common.action_chains import ActionChains
from webdriver_manager.chrome import ChromeDriverManager

# ===== 로깅 =====
logging.basicConfig(
    filename="based_trade.log",
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
)
log = logging.getLogger("based")

# ===== 기본 설정 =====
URL = "https://basedapp.io/BTC"

# 새 크롬 사용자 프로필(권장: 기존 브라우저와 분리)
USER_DATA_DIR = os.path.abspath("./based_profile")
PROFILE_DIR   = "Default"

WINDOW_W, WINDOW_H = 1440, 1080

# 잔액 종료 관련
ENABLE_BALANCE_STOP    = True      # False → 잔액 종료 비활성화
BALANCE_STOP           = 10.0      # 포지션 0일 때 잔액이 이하면 종료
LOW_BAL_CONSEC_NEED    = 2         # 연속 감지 횟수

# 주문/보유/재시도 파라미터
PRICE_IDX          = 2
ORDER_RETRY        = 3
MAX_FILL_WAIT      = 60            # 체결 대기 상한(초)
UI_DELAY           = 0.8
AFTER_75P_DELAY    = 1.5

# 최소 보유 시간(초)
HOLD_MIN_SEC, HOLD_MAX_SEC = 160, 200

# 새로고침/안정화
REFRESH_TRIES         = 3
REFRESH_STABILIZE_S   = 5          # 요청에 따라 5초로 단축
LOOP_STAB_MIN, LOOP_STAB_MAX = 8, 15
RETRY_PAUSE           = 1.2

# ===== 셀렉터 / XPATH =====
SEL_ORDERBOOK_PRICE = "div.z-10.flex.items-center.gap-1.font-medium.text-trading-textUp"

# 주문 버튼
SEL_BTN_SUBMIT      = "#trade-action-button-action"
XPATH_BTN_SUBMIT_FALLBACKS = [
    "//button[@id='trade-action-button-action']",
    "//button[contains(@class,'button-buy') and (contains(., '주문하기') or contains(., 'Place Order'))]",
    "//div[contains(@class,'button-buy-content')][contains(.,'주문하기') or contains(.,'Place Order')]",
    "//div[contains(@class,'button-sell-content')][contains(.,'주문하기') or contains(.,'Place Order')]",
]

# 잔액/포지션
SEL_BALANCE_USDC    = "div.trading-font-number.text-trading-textPrimary.text-sm"
XPATH_POS_TAB       = ("//button[contains(@class,'font-medium') and "
                       "(contains(., '포지션') or contains(., 'Positions'))]")

# 비중 버튼
XPATH_BTN_75P       = "//button[normalize-space()='75%']"

# 포지션 탭 내 청산 버튼 후보(시장가 닫기 / 지정가 종료 등)
XPATH_CLOSE_CANDIDATES = [
    "//button[contains(.,'시장가 닫기')]",
    "//button[contains(.,'지정가 종료')]",
    "//button[contains(.,'Close') and contains(.,'Market')]",
    "//button[contains(.,'Close') and contains(.,'Limit')]",
]

# 미체결 취소 후보
CANCEL_CSS_CANDIDATES = [
    "button[title*='주문 취소']",
    "button[data-tooltip-content*='주문 취소']",
    "button[data-tooltip-id*='order']",
    "button.text-red-400",
    "button.text-red-500",
    "button.text-destructive",
    "button[aria-label*='Cancel']",
    "button[title*='Cancel']",
]
CANCEL_XPATH_CANDIDATES = [
    "//button[contains(., '취소')]",
    "//button[contains(., 'Cancel')]",
    "//button[contains(@class, 'text-red')]",
    "//button[contains(@class, 'text-destructive')]",
]

# ===== Tk 팝업: 로그인/지갑 연결 대기 =====
def wait_for_login_popup():
    root = tk.Tk()
    root.withdraw()
    messagebox.showinfo("시작 준비", "Based에 로그인/지갑 연결을 완료한 뒤 [확인]을 누르세요.")
    try:
        root.destroy()
    except:
        pass

# ===== 유틸 =====
def q(d, css, t=30):
    return WebDriverWait(d, t).until(EC.presence_of_element_located((By.CSS_SELECTOR, css)))

def qa(d, css, t=30):
    WebDriverWait(d, t).until(EC.presence_of_all_elements_located((By.CSS_SELECTOR, css)))
    return d.find_elements(By.CSS_SELECTOR, css)

def click_el(d, el):
    d.execute_script("arguments[0].scrollIntoView({block:'center'});", el)
    time.sleep(0.08)
    try:
        el.click()
    except ElementClickInterceptedException:
        d.execute_script("arguments[0].click();", el)

def robust_click_submit(driver, timeout=8):
    try:
        btn = WebDriverWait(driver, timeout).until(
            EC.element_to_be_clickable((By.CSS_SELECTOR, SEL_BTN_SUBMIT))
        )
        driver.execute_script("arguments[0].scrollIntoView({block:'center'});", btn)
        time.sleep(0.1)
        driver.execute_script("arguments[0].click();", btn)
        return True
    except Exception:
        pass
    for xp in XPATH_BTN_SUBMIT_FALLBACKS:
        try:
            btn = WebDriverWait(driver, 3).until(EC.element_to_be_clickable((By.XPATH, xp)))
            try:
                btn.click()
            except ElementClickInterceptedException:
                driver.execute_script("arguments[0].click();", btn)
            return True
        except Exception:
            continue
    try:
        btn = driver.find_element(By.CSS_SELECTOR, SEL_BTN_SUBMIT)
        ActionChains(driver).move_to_element(btn).pause(0.05).click().perform()
        return True
    except Exception:
        return False

def get_balance(d):
    el = q(d, SEL_BALANCE_USDC, 10)
    raw = el.text.strip().split()[0]
    try:
        return float(raw.replace(",", ""))
    except:
        return 0.0

def get_positions_count(d):
    try:
        el = WebDriverWait(d, 10).until(EC.presence_of_element_located((By.XPATH, XPATH_POS_TAB)))
        m = re.search(r"\((\d+)\)", el.text)
        return int(m.group(1)) if m else 0
    except (TimeoutException, NoSuchElementException):
        return 0

def goto_positions_tab(driver, timeout=8):
    XPATHS = [
        XPATH_POS_TAB,
        "//button[contains(.,'포지션') or contains(.,'Positions')]",
        "//*[self::button or self::a][contains(.,'포지션') or contains(.,'Positions')]",
    ]
    for xp in XPATHS:
        try:
            el = WebDriverWait(driver, timeout).until(EC.element_to_be_clickable((By.XPATH, xp)))
            click_el(driver, el)
            time.sleep(0.2)
            return True
        except Exception:
            continue
    return False

def click_any_close_in_positions(driver):
    """포지션 탭에서 청산 버튼(시장가 닫기/지정가 종료 등) 아무거나 눌러본다."""
    if not goto_positions_tab(driver):
        return False
    for xp in XPATH_CLOSE_CANDIDATES:
        try:
            el = WebDriverWait(driver, 3).until(EC.element_to_be_clickable((By.XPATH, xp)))
            click_el(driver, el)
            return True
        except Exception:
            continue
    return False

def wait_until(d, cond_fn, timeout=MAX_FILL_WAIT, poll=1.5, desc=""):
    t0 = time.time()
    while time.time() - t0 < timeout:
        try:
            if cond_fn():
                return True
        except Exception:
            pass
        time.sleep(poll)
    log.info(f"[대기 타임아웃] {desc} ({timeout}s)")
    return False

def click_75_percent(driver):
    try:
        btn = WebDriverWait(driver, 8).until(EC.element_to_be_clickable((By.XPATH, XPATH_BTN_75P)))
        click_el(driver, btn)
        time.sleep(UI_DELAY)
        return True
    except Exception:
        return False

def find_cancel_buttons(driver):
    found = []
    for css in CANCEL_CSS_CANDIDATES:
        try:
            found.extend(driver.find_elements(By.CSS_SELECTOR, css))
        except Exception:
            pass
    for xp in CANCEL_XPATH_CANDIDATES:
        try:
            found.extend(driver.find_elements(By.XPATH, xp))
        except Exception:
            pass
    try:
        js_nodes = driver.execute_script("""
            const sels = [
              "button[title*='취소']","button[title*='cancel']",
              "button[aria-label*='취소']","button[aria-label*='Cancel']",
              "button.text-red-400","button.text-red-500","button.text-destructive"
            ];
            let out = [];
            for (const s of sels) {
              document.querySelectorAll(s).forEach(b => out.push(b));
            }
            return out;
        """)
        if js_nodes:
            found.extend(js_nodes)
    except Exception:
        pass
    uniq, seen = [], set()
    for el in found:
        try:
            key = (el.id, el.get_attribute("outerHTML")[:100])
        except Exception:
            key = id(el)
        if key in seen:
            continue
        seen.add(key)
        uniq.append(el)
    return uniq

def cancel_open_orders(driver, max_click=60, passes=3, settle=0.2):
    total = 0
    for _ in range(passes):
        btns = find_cancel_buttons(driver)
        clicked_this = 0
        for btn in btns:
            if total >= max_click:
                break
            try:
                driver.execute_script("arguments[0].scrollIntoView({block:'center'});", btn)
                time.sleep(0.05)
                try:
                    btn.click()
                except ElementClickInterceptedException:
                    driver.execute_script("arguments[0].click();", btn)
                clicked_this += 1
                total += 1
                time.sleep(settle)
            except Exception:
                continue
        if clicked_this == 0:
            break
    if total:
        log.info(f"미체결 취소 {total}건 처리")
    else:
        log.info("취소할 미체결 없음/탐색 실패")
    return total

def cancel_all_open_orders_strict(driver, max_rounds=5, settle=0.25):
    total = 0
    for _ in range(max_rounds):
        clicked = cancel_open_orders(driver, max_click=200, passes=3, settle=settle)
        total += clicked
        time.sleep(settle)
        if clicked == 0:
            driver.refresh()
            stabilize_after_refresh()
            clicked2 = cancel_open_orders(driver, max_click=200, passes=2, settle=settle)
            total += clicked2
            if clicked2 == 0:
                break
    log.info(f"엄격 취소 총 {total}건")
    return total

def stabilize_after_refresh():
    log.info(f"새로고침 안정화 {REFRESH_STABILIZE_S}s")
    time.sleep(REFRESH_STABILIZE_S)

def loop_stabilize_pause():
    t = random.randint(LOOP_STAB_MIN, LOOP_STAB_MAX)
    log.info(f"루프 종료 후 안정화 대기 {t}s")
    time.sleep(t)

# ===== 드라이버 =====
def init_driver():
    os.makedirs(USER_DATA_DIR, exist_ok=True)
    opts = Options()
    opts.add_argument(f"--user-data-dir={USER_DATA_DIR}")
    opts.add_argument(f"--profile-directory={PROFILE_DIR}")
    opts.add_argument(f"--window-size={WINDOW_W},{WINDOW_H}")
    opts.add_experimental_option("excludeSwitches", ["enable-automation"])
    opts.add_experimental_option("useAutomationExtension", False)
    opts.add_experimental_option("detach", True)
    # 크롬 알림 줄이기(선택)
    opts.add_argument("--disable-notifications")
    return webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=opts)

# ===== 메인 =====
def main():
    try:
        driver = init_driver()
    except WebDriverException as e:
        if "user data directory is already in use" in str(e):
            msg = "같은 프로필을 쓰는 크롬이 열려 있음. 모든 크롬 종료하거나 전용 프로필 경로를 사용하세요."
            log.error(msg)
            # 무콘솔 환경에서 사용자 안내
            try:
                root = tk.Tk(); root.withdraw()
                messagebox.showerror("오류", msg)
                root.destroy()
            except:
                pass
            sys.exit(1)
        raise

    driver.get(URL)
    wait_for_login_popup()

    low_bal_streak = 0

    while True:
        try:
            bal = get_balance(driver)
            pos_n = get_positions_count(driver)
            log.info(f"[잔액] {bal:.2f} USDC | [포지션] {pos_n}개")

            # 잔액 종료(포지션 0일 때만)
            if ENABLE_BALANCE_STOP and pos_n == 0:
                if bal <= BALANCE_STOP:
                    low_bal_streak += 1
                    log.info(f"낮은 잔액 감지 {low_bal_streak}/{LOW_BAL_CONSEC_NEED}")
                else:
                    low_bal_streak = 0
                if low_bal_streak >= LOW_BAL_CONSEC_NEED:
                    log.info(f"(포지션 0개) 잔액 {BALANCE_STOP} 이하 {LOW_BAL_CONSEC_NEED}회 연속 → 종료")
                    break

            # ===== 진입 루틴 =====
            success_entry = False
            planned_exit_at = None

            for attempt in range(1, ORDER_RETRY + 1):
                try:
                    cancel_all_open_orders_strict(driver)

                    rows = qa(driver, SEL_ORDERBOOK_PRICE, 20)
                    idx = max(1, min(PRICE_IDX, len(rows))) - 1
                    click_el(driver, rows[idx])
                    time.sleep(0.25)

                    if not click_75_percent(driver):
                        log.info(f"[진입 재시도 {attempt}] 75% 클릭 실패")
                        time.sleep(RETRY_PAUSE); continue

                    time.sleep(AFTER_75P_DELAY)
                    if not robust_click_submit(driver):
                        log.info(f"[진입 재시도 {attempt}] 주문하기 클릭 실패")
                        time.sleep(RETRY_PAUSE); continue

                    log.info("[진입] 주문하기 → 체결 대기")
                    if wait_until(driver, lambda: get_positions_count(driver) > 0,
                                  timeout=MAX_FILL_WAIT, desc="진입 체결"):
                        success_entry = True
                        hold_sec = random.randint(HOLD_MIN_SEC, HOLD_MAX_SEC)
                        planned_exit_at = time.monotonic() + hold_sec
                        log.info(f"진입 체결 — 최소 보유 {hold_sec}s")
                        break

                    log.info(f"[진입 재시도 {attempt}] 체결 실패 → 미체결 전부 취소 후 재주문")
                    cancel_all_open_orders_strict(driver)

                except Exception as e:
                    log.exception(f"[진입 재시도 {attempt}] 예외: {e}")

                for i in range(REFRESH_TRIES):
                    log.info(f"진입 실패 새로고침 {i+1}/{REFRESH_TRIES}")
                    driver.refresh()
                    stabilize_after_refresh()
                    if get_positions_count(driver) > 0:
                        success_entry = True
                        hold_sec = random.randint(HOLD_MIN_SEC, HOLD_MAX_SEC)
                        planned_exit_at = time.monotonic() + hold_sec
                        log.info(f"새로고침 중 포지션 확인 — 최소 보유 {hold_sec}s")
                        break
                if success_entry:
                    break

            if not success_entry:
                log.info("진입 실패 → 다음 루프")
                loop_stabilize_pause()
                continue

            # ===== 최소 보유 =====
            while time.monotonic() < planned_exit_at:
                time.sleep(5)
            log.info("최소 보유시간 경과 — 청산 루틴")

            # ===== 청산 루틴(포지션 탭) =====
            success_close = False
            for attempt in range(1, ORDER_RETRY + 1):
                try:
                    if click_any_close_in_positions(driver):
                        log.info(f"[청산] 포지션 탭 청산 클릭(시도 {attempt}) → 포지션 0 대기")
                        if wait_until(driver, lambda: get_positions_count(driver) == 0,
                                      timeout=MAX_FILL_WAIT, desc="청산"):
                            success_close = True
                            log.info("청산 완료(포지션 0)")
                            break
                        log.info("[청산] 체결 지연 → 동일 재시도 준비")
                        time.sleep(RETRY_PAUSE)
                    else:
                        log.info("[청산] 포지션 탭 청산 버튼 탐색 실패")
                except Exception as e:
                    log.exception(f"[청산 시도 {attempt}] 예외: {e}")

                for i in range(REFRESH_TRIES):
                    log.info(f"청산 실패 새로고침 {i+1}/{REFRESH_TRIES}")
                    driver.refresh()
                    stabilize_after_refresh()
                    try:
                        if click_any_close_in_positions(driver):
                            log.info("새로고침 후 청산 클릭")
                    except Exception:
                        pass
                    if wait_until(driver, lambda: get_positions_count(driver) == 0,
                                  timeout=MAX_FILL_WAIT, desc="청산"):
                        success_close = True
                        log.info("새로고침 중 포지션 0")
                        break
                if success_close:
                    break

            if not success_close:
                log.info("청산 미확인 → 다음 루프(수동 확인 권장)")
                loop_stabilize_pause()
                continue

            loop_stabilize_pause()

        except WebDriverException as e:
            log.error(f"WebDriver 예외: {e}")
            # 브라우저가 사라졌다면 종료
            try:
                _ = driver.window_handles
            except Exception:
                log.info("브라우저가 닫혀 자동 종료합니다.")
                break
            # 그 외엔 재시도
            time.sleep(3)

        except Exception as e:
            log.exception(f"[루프 예외] {e}")
            try:
                driver.refresh()
                stabilize_after_refresh()
            except Exception:
                pass
            loop_stabilize_pause()

if __name__ == "__main__":
    main()
